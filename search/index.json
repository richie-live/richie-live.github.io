[{"content":"ICML 2025\nAbstract: Reliable planning is crucial for achieving autonomous driving. Rule-based planners are efficient but lack generalization, while learning-based planners excel in generalization yet have limitations in real-time performance and interpretability. In long-tail scenarios, these challenges make planning particularly difficult. To leverage the strengths of both rule-based and learning-based planners, we proposed the Scenario-Aware Hybrid Planner (SAH-Drive) for closed-loop vehicle trajectory planning. Inspired by human driving behavior, SAH-Drive combines a lightweight rule-based planner and a comprehensive learningbased planner, utilizing a dual-timescale decision neuron to determine the final trajectory. To enhance the computational efficiency and robustness of the hybrid planner, we also employed a diffusion proposal number regulator and a trajectory fusion module. The experimental results show that the proposed method significantly improves the generalization capability of the planning system, achieving state-of-the-art performance in interPlan, while maintaining computational efficiency without incurring substantial additional runtime.\n","date":"2025-07-03T00:00:00Z","image":"https://richie-live.github.io/p/sah-drive-a-scenario-aware-hybrid-planner-for-closed-loop-vehicle-trajectory-generation/featured_hu_9ca0a5931e220eae.png","permalink":"https://richie-live.github.io/p/sah-drive-a-scenario-aware-hybrid-planner-for-closed-loop-vehicle-trajectory-generation/","title":"SAH-Drive: A Scenario-Aware Hybrid Planner for Closed-Loop Vehicle Trajectory Generation"},{"content":"好久没有写博客了，感觉这是一个前期需要坚持的习惯，其实也花不了多少时间，反而能加倍巩固学习到的知识。虽然门槛还是有，开始也会觉得效率很低，但只要习惯了，以后总结文章，发布，这一套流程会走的越来越熟悉，就不会那么消耗精力，只是顺手的事情。也就是说克服了前期的困难，好处是大大的有。\n今天新读了一本书：学会思考。主要讲的是批判性思维，有四个关键步骤：\n是什么 怎们样：这件事会带来什么影响 为什么：如果是证明影响，为什么；如果是负面影响，为什么 怎么做 我个人的理解是，这是一种积极思维的思考习惯，最终让人专注于思考怎么做，有利于求同存异，有利于冲突消除和最后达到和谐的目标以及个体和群体的共同进步。总的来说，这是一个很好的思想，我在今天和家人的通话中实践了这个思想，有的时候不要那么着急，不让内心的本能操控自己，去沟通，确实能够和平的传达本意和思想。\n","date":"2025-06-30T21:16:12+08:00","permalink":"https://richie-live.github.io/p/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4/","title":"批判性思维"},{"content":"由于需要下载一个大数据集，本来电脑的1T固态不够用了，需要加装固态硬盘。我购买了一个4T的固态硬盘，主机装上之后还有一系列格式化和挂载的操作，也是有点麻烦，在此记录一下，主要有以下几个步骤：\n对硬盘进行分区并格式化 运行终端命令df -h，查看现有硬盘分区及挂载状态，发现没有新增的固态硬盘。\n所有安装的硬盘状态：sudo fdisk -l\n找到新增但还没有挂载的固态硬盘，以/dev/nvme01为例，进入并进行分区\n1 2 3 4 5 sudo fdisk /dev/nvme01 n # 创建分区 p # 创建主分区 1 # 分区编号，接下来会有两个回车 w # 保存 基本就是按照默认的来就行了，最后w保存硬盘修改\n再次sudo fdisk -l，找到硬盘下的新分区，又称为设备（device boot），以/dev/nvme01p1为例子\n格式化该分区：mkfs -t ext4 -c /dev/sdb1\n-t 制定要把磁盘格式化成什么类型\n-c 在建立文件系统之前检查环道，要等一段时间，新硬盘一般不需要\n挂载 创建挂载点并进行挂载\n1 2 mkdir /ssd sudo mount /dev/nvme01p1 /ssd 设置开机自动挂载，查看硬盘的UUID\nsudo blkid /dev/nvme01p1\ncode /etc/fstab\n在文件最后添加 UUID=abcd-1234 /ssd ext4 defaults 0 0 测试是否能正常挂载：sudo mount -a 无报错说明添加成功。\n/etc/fstab 文件结构\n每一行的格式是：\n1 \u0026lt;设备名或UUID\u0026gt; \u0026lt;挂载点\u0026gt; \u0026lt;文件系统类型\u0026gt; \u0026lt;挂载选项\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;fsck\u0026gt; 第1列：磁盘分区，通常用 UUID=... 以保证设备插拔或路径变化后仍能识别 第2列：挂载点，比如 /（根目录）或 /boot/efi 第3列：文件系统类型，如 ext4、vfat、swap 第4列：挂载选项，如 defaults、errors=remount-ro 第5列 dump：通常是 0（表示不需要做备份） 第6列 fsck顺序：1 表示首先检查（通常是根分区），2 表示之后检查，0 表示不检查 ","date":"2025-06-30T00:00:00Z","permalink":"https://richie-live.github.io/p/ubantu%E5%8A%A0%E8%A3%85%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E6%95%99%E7%A8%8B/","title":"Ubantu加装固态硬盘教程"},{"content":"安装docker engine，不要安装docker desktop Docker Desktop 是针对 Windows 和 Mac 用户设计的应用，它包含了 Docker 引擎（Docker Engine）和 Docker CLI 工具。对于这些操作系统，Docker Desktop 会启用一个虚拟机（通过 Hyper-V 或 WSL 2）来运行容器，而不是像 Linux 系统那样直接在宿主机上运行 Docker 服务。 在 Linux 系统 上，你需要使用 Docker Engine，而不是 Docker Desktop。 此外网上大多数教程都是针对Docker Engine的。 Ubantu安装教程 Ubuntu | Docker Docs\n直接运行\n1 2 3 4 5 6 7 8 9 10 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.xuanyuan.me\u0026#34; ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker Docker加速 镜像 2025 Docker/DockerHub 国内镜像源/加速列表 Docker 国内镜像加速地址-长期更新(2025-06) - 讲文张字 - 博客园\n这些镜像通常只能pull不能search，要search直接去dockerhub网站，要在终端可以用下面的方法：配置代理\n配置代理 方法一 1 2 sudo mkdir -p /etc/systemd/system/docker.service.d sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf 添加以下内容并保存，端口号7890根据电脑实际情况修改\n1 2 3 4 [Service] Environment=\u0026#34;HTTP_PROXY=http://127.0.0.1:7890/\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://127.0.0.1:7890/\u0026#34; Environment=\u0026#34;NO_PROXY=192.168.*,172.31.*,172.30.*,172.29.*,172.28.*,172.27.*,172.26.*,172.25.*,172.24.*,172.23.*,172.22.*,172.21.*,172.20.*,172.19.*,172.18.*,172.17.*,172.16.*,10.*,127.*,localhost\u0026#34; 重新加载 systemd 并重启 Docker\n1 2 sudo systemctl daemon-reload sudo systemctl restart docker 方法二 配置全局代理\n1 sudo vim ~/.docker/config.json 配置 HTTP 和 HTTPS 代理：\n1 2 3 4 5 6 7 8 9 { \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://proxy.example.com:3128\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;https://proxy.example.com:3129\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;*.test.example.com,.example.org,127.0.0.0/8\u0026#34; } } } 开启容器代理\n1 2 3 4 5 --env HTTP_PROXY=\u0026#34;http://172.18.0.1:7897/\u0026#34;\\ --env HTTPS_PROXY=\u0026#34;http://172.18.0.1:7897/\u0026#34;\\ --env http_proxy=\u0026#34;http://172.18.0.1:7897/\u0026#34;\\ --env https_proxy=\u0026#34;http://172.18.0.1:7897/\u0026#34;\\ --env NO_PROXY=\u0026#34;localhost,127.0.0.1,.example.com\u0026#34;\\ 查看docker网卡地址，运行ifconfig 假设得到docker0地址为：172.18.0.1\nhttp://proxy.example.com 填172.18.0.1\n安装 NVIDIA Container Toolkit Installing the NVIDIA Container Toolkit — NVIDIA Container Toolkit\n安装完成之后配置docker\n1 sudo nvidia-ctk runtime configure --runtime=docker 重启docker服务\n1 sudo systemctl restart docker 下载镜像 去dockerhub搜索 Docker Hub Container Image Library | App Containerization\n找到想要的镜像之后进行docker pull，可以直接copy code运行，举个例子\n1 docker pull nginx:stable-perl 运行镜像 1 2 3 4 5 6 7 8 9 10 11 docker run --gpus all -itd \\ -p 30000:30000 \\ -p 5006:5006 \\ -v /home/fyq/SAH-Drive:/root/SAH-Drive \\ -v /home/fyq/nuplan:/root/nuplan \\ -v /home/fyq/interplan_workspace:/root/interplan_workspace \\ --name nuplan_docker1 \\ --env http_proxy=\u0026#34;http://172.18.0.1:7897/\u0026#34; \\ --env https_proxy=\u0026#34;http://172.18.0.1:7897/\u0026#34; \\ --env NO_PROXY=\u0026#34;localhost,127.0.0.1,.example.com\u0026#34; \\ sah_nuplan_image:latest /bin/bash \u0026ndash;gpus all：将所有 GPU 暴露给容器。也可以指定 GPU 数量或 ID，比如 \u0026ndash;gpus \u0026lsquo;\u0026ldquo;device=0,1\u0026rdquo;\u0026rsquo; -it：交互模式，进入容器 -d 让容器在后台运行，保持容器常开 nvidia/cuda:12.4.1-runtime-ubuntu22.04：你的镜像名称，比如 my-gpu-image /bin/bash：进入容器 shell（可按需修改为运行的脚本或命令） \u0026ndash;name: 给容器起的名字 \u0026ndash;env 环境变量 注意，运行容器的终端需要开启http代理\n退出 进入 容器 1. 退出容器 如果你在容器内部使用 bash 或其他 shell，想要退出容器，可以使用以下命令：\n1 exit 这会让你退出当前的容器 shell 会话，容器仍然在后台运行（如果是交互模式且没有显式停止容器）。\n或者，如果你只是想暂时返回主机的命令行，也可以按 Ctrl + P，然后 Ctrl + Q，这样容器会在后台继续运行，而你会返回到主机的命令行。\n2. 查看正在运行的容器 如果你退出了容器，但想再次进入容器，首先需要确认容器是否在运行。可以使用以下命令查看当前正在运行的容器：\n1 docker ps 这将显示所有正在运行的容器，包括容器 ID 和名称等信息。\n1 docker ps -a 这将显示所有的容器，包括没有运行的。\n3. 再次进入容器 你可以通过容器 ID 或名称再次进入容器。使用以下命令：\n1 docker exec -it \u0026lt;container_id_or_name\u0026gt; /bin/bash 4. 进入已停止的容器 如果容器已经停止，你可以先重新启动容器，然后再进入容器：\n1 docker start \u0026lt;container_id_or_name\u0026gt; 然后再次使用 docker exec 进入容器：\n1 docker exec -it \u0026lt;container_id_or_name\u0026gt; /bin/bash 缓存清理 docker清除构建缓存\n1 docker builder prune 清理未使用的镜像、容器、卷和网络 docker system prune\n这条命令会删除：\n未运行的容器（停止的容器） 悬挂镜像（没有标签的镜像） 未使用的网络 未使用的卷（可以加 \u0026ndash;volumes 参数来删除未使用的卷） docker导致的文件夹权限问题 容器中创建的文件或文件夹的属主是 root 用户，可能导致主机用户（如 fyq）没有权限修改或删除。\n假设容器运行后你发现主机文件夹 /home/fyq/nuplan/exp/... 是 root 拥有的。\n你可以在主机上运行以下命令将属主改回自己：\n1 sudo chown -R fyq:fyq /home/fyq/nuplan/exp 拷贝文件进入容器 1 docker cp path/host path/container docker cp 有一个已知限制：它不能递归地覆盖已有的目录结构中的单个文件，尤其是容器内目标路径已经存在且非空的情况下。 只能先删除容器内的目标目录，再copy。\ndockerfile常用命令 1. FROM：指定基础镜像（必须的第一行） 1 FROM ubuntu:20.04 2. RUN：在镜像中执行命令（用于安装软件等） 1 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y python3 3. COPY：将本地文件/目录复制到镜像中 1 COPY ./app /usr/src/app 4. ADD：类似 COPY，但支持自动解压 .tar 文件及远程下载 1 ADD https://example.com/file.tar.gz /tmp/ 5. WORKDIR：设置工作目录（后续命令会在此目录下执行） 1 WORKDIR /usr/src/app 6. CMD：指定容器启动时默认执行的命令（只生效一次） 1 CMD [\u0026#34;python3\u0026#34;, \u0026#34;main.py\u0026#34;] 7. ENTRYPOINT：指定容器启动命令（常用于将容器当作命令运行） 1 ENTRYPOINT [\u0026#34;python3\u0026#34;, \u0026#34;main.py\u0026#34;] 8. ENV：设置环境变量 1 2 ENV PATH=\u0026#34;/opt/conda/bin:$PATH\u0026#34; ENV LANG C.UTF-8 9. EXPOSE：声明容器监听的端口（不自动映射） 1 EXPOSE 8080 10. VOLUME：声明挂载点（用于持久化数据） 1 VOLUME [\u0026#34;/data\u0026#34;] 11. ARG：构建时传参（与 ENV 区别是生命周期） 1 2 ARG VERSION=1.0 RUN echo \u0026#34;Version is $VERSION\u0026#34; 从dockerfile构建容器\n1 docker build -t your-image-name . ","date":"2025-06-05T00:00:00Z","permalink":"https://richie-live.github.io/p/ubantu22.04%E9%83%A8%E7%BD%B2docker%E6%95%99%E7%A8%8B/","title":"Ubantu22.04部署Docker教程"},{"content":"本文主要记录一下新手小白在arxiv注册与投稿极有可能遇到的两个坑，也是我所遇到的问题。\n要拿edu邮箱注册，不然需要其他已经在arxiv发过三篇以上文章的人背书，直接用edu邮箱是最简单的，本人就踩了这个坑。 用overleaf的要上传latex源码，并且要在overleaf选择texlive2023进行编译通过之后再上传至arxiv进行编译，不然很有可能出错。 ","date":"2025-05-30T00:00:00Z","permalink":"https://richie-live.github.io/p/arxiv%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%8A%95%E7%A8%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"arxiv注册与投稿注意事项"},{"content":"扩散模型中三种加入条件的方式 条件扩散模型是如何保证模型学到条件的\n三种加入条件的总结 扩散模型中三种加入条件的方式\nVanilla Guidance：直接在原本的无条件扩散生成模型的神经网络中，再开一个条件信息进入的入口，然后训练这个神经网络 Classifier Guidance：训练一个分类器神经网络，在去噪生成的过程中进行条件引导 Classifier-Free Guidance：为了不训练额外的 classifier，classifier-free guidance 融合了 unconditional model 以及 vanilla guidance。它鼓励模型在 guidance 方向抽样，同时偏离 unconditional model 的抽样方向。其公式为： $$ \\nabla_{x} \\log p(x \\mid c)=w \\nabla_{x} \\log p(x \\mid c)+(1-w) \\nabla_{x} \\log p(x) $$在扩散模型（Diffusion Models）中，加入条件的方法主要有三种：Vanilla Guidance、Classifier Guidance 和 Classifier-Free Guidance。这些方法通过不同的方式将条件信息引入模型，进而影响生成结果。以下是对这三种方法的详细解释，并附上相关公式。\nVanilla Guidance（传统引导） Vanilla Guidance 是最基本的一种方法，其中条件信息是通过改变模型的潜在空间来引导生成过程。其基本思想是将条件信息作为模型的输入之一，在每一步的反向扩散过程中，根据条件信息调整生成的分布。\n过程：\n假设你有一个条件 $c$，并且模型希望生成与 $c$ 相关的样本。 在标准的扩散模型中，我们有一个由噪声逐渐反向扩散生成数据的过程。给定条件 $c$，我们希望模型的生成结果符合该条件。 公式： 反向扩散的步骤通常使用如下的更新规则：\n$$\\mathbf{x}_{t-1} = \\mathbf{x}_t + \\Delta \\mathbf{x}_t$$其中，$\\Delta \\mathbf{x}_t$ 是通过条件信息 $c$ 调整的预测噪声。具体地，调整后的噪声预测可以通过以下方式得到：\n$$\\Delta \\mathbf{x}_t = f(\\mathbf{x}_t, c)$$其中，$f$ 是一个函数，它将当前图像 $\\mathbf{x}_t$ 和条件 $c$ 作为输入，并输出一个噪声更新量。这个方法可以通过调整 $f$ 来控制条件对生成结果的影响。\nClassifier Guidance（分类器引导） Classifier Guidance 通过引入一个分类器来帮助模型在反向扩散过程中进行更有针对性的引导。该方法通常使用一个预训练的分类器网络来根据条件 $c$ 调整反向扩散过程中的噪声预测。\n过程：\n使用一个额外的分类器网络来计算条件信息与当前生成样本之间的关系。 分类器网络 $q(c | \\mathbf{x})$ 预测在当前步骤 $\\mathbf{x}_t$ 下的条件 $c$，然后通过调整噪声的预测来引导模型生成更符合条件的信息。 公式： 假设我们有一个生成样本的目标分布 $p_{\\theta}(\\mathbf{x}_t | c)$，在引导过程中，我们通过分类器提供的梯度来调整反向过程的噪声更新：\n$$\\Delta \\mathbf{x}_t = \\mathbf{\\epsilon}_\\theta(\\mathbf{x}_t, t) + \\lambda \\nabla_{\\mathbf{x}_t} \\log q(c | \\mathbf{x}_t)$$其中，$\\mathbf{\\epsilon}_\\theta(\\mathbf{x}t, t)$ 是标准的噪声预测，$\\lambda$ 是引导的强度超参数，$\\nabla{\\mathbf{x}_t} \\log q(c | \\mathbf{x}_t)$ 是分类器的梯度，用来指导模型生成更符合条件 $c$ 的样本。\nClassifier-Free Guidance（无分类器引导） Classifier-Free Guidance 是一种不依赖于外部分类器的引导方法，通常通过将条件信息直接融入模型的噪声预测中，来实现对生成过程的引导。与分类器引导不同，它不需要一个预训练的分类器，而是将条件信息嵌入到模型的结构中。\n过程：\n在每一步的反向扩散过程中，模型通过将条件信息与噪声预测进行结合来实现引导。具体地，模型在预测噪声时，会根据是否提供条件来调整输出。 通过条件输入，模型学会在生成过程中自我引导，无需额外的外部分类器。 公式： 假设模型在反向扩散时的噪声预测是基于条件 $c$ 和无条件输入的组合：\n$$\\Delta \\mathbf{x}_t = \\mathbf{\\epsilon}_\\theta(\\mathbf{x}_t, c, t) - \\mathbf{\\epsilon}_\\theta(\\mathbf{x}_t, \\emptyset, t)$$其中：\n$\\mathbf{\\epsilon}_\\theta(\\mathbf{x}_t, c, t)$ 是基于条件 $c$ 的噪声预测； $\\mathbf{\\epsilon}_\\theta(\\mathbf{x}_t, \\emptyset, t)$ 是无条件的噪声预测（即没有给定条件的预测）。 这种方式通过计算有条件和无条件的差异来引导生成过程。 总结 Vanilla Guidance 直接将条件作为输入，影响反向扩散过程的噪声更新。 Classifier Guidance 使用一个外部预训练的分类器来提供梯度信息，调整噪声预测。 Classifier-Free Guidance 不依赖于外部分类器，而是通过条件和无条件模型的差异来引导生成。 每种方法有不同的优缺点。Vanilla Guidance 实现简单，但可能较难控制生成结果；Classifier Guidance 通过分类器精细调控生成结果，但需要预训练分类器；Classifier-Free Guidance 则去除了对分类器的依赖，减少了外部资源的需求，但可能在某些任务上效果不如分类器引导。\n","date":"2025-05-28T00:00:00Z","permalink":"https://richie-live.github.io/p/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%8A%A0%E5%85%A5%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","title":"扩散模型加入条件的三种方式"},{"content":"Abstract: The problem of attitude planning for spacecraft with movable parts under complex pointing constraints is addressed in this paper. To avoid tackling the complex pointing constraints in the high-dimensional system, a novel decoupled strategy is proposed to map the pointing space to the attitude space. Path-planning algorithm Rapidly-exploring Random Tree (RRT)*-Smart is employed in pointing space to generate a collision-free pointing path, and piecewise quintic polynomials are used to represent the attitude path. By proving the differential flatness of spacecraft with movable parts, the inverse dynamics is used to acquire attitude state trajectory in state space. Benefiting from the decoupled strategy, the attitude state trajectory is optimized by a new heuristic time allocation algorithm using binary search with no gradient information needed. The simulation results are discussed, and the performance during each scenario is analyzed.\n","date":"2023-11-14T00:00:00Z","image":"https://richie-live.github.io/p/polynomial-attitude-trajectory-planning-for-spacecraft-with-movable-parts-using-decoupled-strategy/featured_hu_d78f77da5a36c64c.png","permalink":"https://richie-live.github.io/p/polynomial-attitude-trajectory-planning-for-spacecraft-with-movable-parts-using-decoupled-strategy/","title":"Polynomial Attitude Trajectory Planning for Spacecraft with Movable Parts Using Decoupled Strategy"},{"content":"Abstract The objective of this paper is to plan a time-optimal attitude trajectory in a relatively short time for spacecraft with movable parts under complex pointing constraints. The constrained attitude planning problem is ﬁrst established, then the constraints on attitude maneuvers are described. The time-optimal attitude planning for rigid spacecraft body is decoupled into geometric level and dynamic level through the addition of the path scalar. To obtain a given safe path in quaternion space, RRT*-Smart path planning and spherical and quadrangle (SQUAD) interpolation are carried out at the geometric level. The timeoptimal parameterization for a given path is reformulated as a second order cone programming (SOCP) problem at the dynamic level through a nonlinear change in variables and the addition of various convexity-preserving extensions. In order to overcome the issue of high system dimension caused by the movable parts, a decoupled attitude planning method is designed to generate the quaternion trajectory of the spacecraft body and the rotation angle trajectory of the movable parts respectively. In comparison to GPOPS, the simulation results demonstrate that the proposed method can plan a suboptimal solution in milliseconds. Furthermore, the performance indicator for energy consumption is better.\nSimulation Results ","date":"2023-08-28T00:00:00Z","image":"https://richie-live.github.io/p/time-optimal-attitude-planning-for-spacecraft-with-movable-parts-using-second-order-cone-programming/featured_hu_d78f77da5a36c64c.png","permalink":"https://richie-live.github.io/p/time-optimal-attitude-planning-for-spacecraft-with-movable-parts-using-second-order-cone-programming/","title":"Time-optimal attitude planning for spacecraft with movable parts using second order cone programming"},{"content":"明月山 杭州西湖 滑雪 北京野生动物园 ","date":"2023-08-26T00:00:00Z","image":"https://richie-live.github.io/p/%E6%97%85%E8%A1%8C%E5%9B%BE%E5%86%8C/featured_hu_ea93dc80288a8d38.png","permalink":"https://richie-live.github.io/p/%E6%97%85%E8%A1%8C%E5%9B%BE%E5%86%8C/","title":"旅行图册"},{"content":"摘要 在引力波探测任务中，针对大尺度激光建链时目标姿态动态变化以及姿态机动约束复杂的问题，提出了引力波探测卫星动态姿态规划方法。首先给出引力波探测卫星的最优目标姿态求解方法。然后，设计了随机节点启发式扩展方法和目标姿态实时更新方法，对力矩轨迹进行平滑处理，实现了动态目标姿态规划。仿真结果表明，与经典RRT姿态规划方法相比，本文提出的方法具有更高的指向精度，并且消耗能量少，可满足引力波探测卫星大尺度建链保持的任务需求。\n仿真结果 使用经典RRT算法和改进RRT算法进行姿态规划，仿真结果如下：\n","date":"2022-08-01T00:00:00Z","image":"https://richie-live.github.io/p/%E4%B8%80%E7%A7%8D%E5%BC%95%E5%8A%9B%E6%B3%A2%E6%8E%A2%E6%B5%8B%E5%8D%AB%E6%98%9F%E5%8A%A8%E6%80%81%E5%A7%BF%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/featured_hu_595b1cc1f761b504.png","permalink":"https://richie-live.github.io/p/%E4%B8%80%E7%A7%8D%E5%BC%95%E5%8A%9B%E6%B3%A2%E6%8E%A2%E6%B5%8B%E5%8D%AB%E6%98%9F%E5%8A%A8%E6%80%81%E5%A7%BF%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/","title":"一种引力波探测卫星动态姿态规划方法"}]